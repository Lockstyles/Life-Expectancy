# -*- coding: utf-8 -*-
"""LifeExpectancy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bZNifkkF4wjFYp72PcyNiZi-NcMMPVIj
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go

from sklearn.impute import SimpleImputer
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score

from tensorflow.keras.layers import Dense
from tensorflow.keras.models import Sequential
from tensorflow.keras.utils import plot_model

df = pd.read_csv('Life Expectancy Data.csv')

df.info()

df.shape

df.isnull().sum()

df.describe()

num_cols = df.select_dtypes(include=['int','float']).columns
for i in num_cols:
   print(df[i].value_counts())

df['Country'].value_counts()

df['Status'].value_counts()

df.dropna(subset=['Life expectancy '],how='all',inplace=True)
df.isnull().sum()

imputer = SimpleImputer(strategy='mean')

columns_with_missing_values = ['Adult Mortality', 'Alcohol', 'Hepatitis B', ' BMI ', 'Polio', 'Total expenditure', 'Diphtheria ', 'GDP', 'Population', ' thinness  1-19 years', ' thinness 5-9 years', 'Income composition of resources', 'Schooling']
for column in columns_with_missing_values:
    df[column] = imputer.fit_transform(df[[column]])

df.isnull().sum()

for column in df.columns:
    fig = px.box(df, y=column, title=f'Box Plot for {column}')

    fig.update_layout(
        title=dict(text=f'<b>Box Plot for {column}</b>', x=0.5),
        boxmode='group'
    )

    fig.show()

columns_with_outliers = [
    'Adult Mortality', 'infant deaths', 'Alcohol', 'percentage expenditure',
    'Hepatitis B', 'Measles ', ' BMI ', 'under-five deaths ', 'Polio',
    'Total expenditure', 'Diphtheria ', ' HIV/AIDS', 'GDP', 'Population',
    ' thinness  1-19 years', ' thinness 5-9 years',
    'Income composition of resources', 'Schooling'
]
for column in columns_with_outliers:
    Q1 = df[column].quantile(0.25)
    Q3 = df[column].quantile(0.75)
    IQR = Q3 - Q1

    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    df[column] = np.where((df[column] > upper_bound) | (df[column] < lower_bound), np.mean(df[column]), df[column])

for column in df.columns:
    fig = px.box(df, y=column, title=f'Box Plot for {column}')

    fig.update_layout(
        title=dict(text=f'<b>Box Plot for {column}</b>', x=0.5),
        boxmode='group'
    )

    fig.show()

fig = px.histogram(df, x='Year', color='Year', title='Count Plot for Year')

fig.update_layout(
    title=dict(text='<b>Count Plot for Year</b>', x=0.5)
)

fig.show()

fig = px.line(df.sort_values(by='Year'), x='Year', y='Life expectancy ',animation_frame='Country',animation_group='Year',color='Country', title='Trend of Life Expectancy Over the Years')

fig.update_layout(
    title=dict(text='<b>Trend of Life Expectancy Over the Years</b>', x=0.5)
)

fig.show()

fig = px.histogram(df, x='Status', color='Status', title='Count Plot for Status of Country')

fig.update_layout(
    title=dict(text='<b>Count Plot for Status of Country</b>', x=0.5)
)

fig.show()

developing_df = df[df['Status'] == 'Developing']

fig = px.histogram(developing_df, x='Life expectancy ', title="Life Expectancy of Developing Nations")
fig.update_layout(
    xaxis_title='',
    yaxis_title='Count of Ages',
    title_text='<b>Life Expectancy of Developing Countries</b>',
    title_x=0.5,
)
fig.show()

developing_df = df[df['Status'] == 'Developed']

fig = px.histogram(developing_df, x='Life expectancy ', title="Life Expectancy of Developing Nations")
fig.update_layout(
    xaxis_title='',
    yaxis_title='Count of Ages',
    title_text='<b>Life Expectancy of Developed Countries</b>',
    title_x=0.5,  # Center title
)
fig.show()

fig = px.bar(df.groupby('Status', as_index=False).agg({'Adult Mortality':'mean'}),
             x='Status',
             y='Adult Mortality',
             color='Status',
             title='Average Adult Mortality of Developing and Developed Countries')

fig.update_layout(title_text='<b>Average Adult Mortality of Developing and Developed Countries</b>', title_x=0.5)

fig.show()

fig = px.bar(df.groupby('Status', as_index=False).agg({'infant deaths':'mean'}),
             x='Status',
             y='infant deaths',
             color='Status',
             title='Average Infant deaths of Developing and Developed Countries')

fig.update_layout(title_text='<b>Average Infant deaths of Developing and Developed Countries</b>', title_x=0.5)

fig.show()

fig = px.bar(df.groupby('Status', as_index=False).agg({'Alcohol':'mean'}),
             x='Status',
             y='Alcohol',
             color='Status',
             title='Average Alcohol consumption of Developing and Developed Countries')

fig.update_layout(title_text='<b>Average Alcohol consumption of Developing and Developed Countries</b>', title_x=0.5)

fig.show()

fig = px.scatter(df.sort_values(by='Year'), x='Life expectancy ', y='Adult Mortality',color='Country', size='Year', title='Life expectancy vs Adult Mortality for Countries over Years')

fig.update_layout(title_text='<b>Life expectancy vs Adult Mortality for Countries over Years</b>', title_x=0.5)

fig.show()

fig = px.scatter(df.sort_values(by='Year'), x='Life expectancy ', y='infant deaths',color='Country', size='Year', title='Life expectancy vs Infant deaths for Countries over Years')

fig.update_layout(title_text='<b>Life expectancy vs Infant deaths for Countries over Years</b>', title_x=0.5)

fig.show()

numeric_columns = df.select_dtypes(include=['int64', 'float64']).columns

correlation_matrix = df[numeric_columns].corr()

fig = px.imshow(correlation_matrix,
                labels=dict(x='Columns', y='Columns', color='Correlation'),
                x=correlation_matrix.columns,
                y=correlation_matrix.columns,
                color_continuous_scale='blues',
                title='Heatmap: Correlation Matrix of Numeric Columns')


fig.update_layout(title_text='<b> Heatmap: Correlation Matrix of Numeric Columns </b>', title_x=0.5 ,width=1200 ,height=1200)
fig.show()

df['Country'].unique()

df['Status'].unique()

cols_to_encode = ['Country', 'Status']

label_encoder_df = LabelEncoder()
for col in cols_to_encode:
    df[col] = label_encoder_df.fit_transform(df[col])

df['Country'].unique()

df['Status'].unique()



X = df.drop('Life expectancy ', axis=1)
y = df['Life expectancy ']

cols_to_scale = ['Country', 'Year', 'Adult Mortality',
       'infant deaths', 'Alcohol', 'percentage expenditure', 'Hepatitis B',
       'Measles ', ' BMI ', 'under-five deaths ', 'Polio', 'Total expenditure',
       'Diphtheria ', ' HIV/AIDS', 'GDP', 'Population',
       ' thinness  1-19 years', ' thinness 5-9 years',
       'Income composition of resources', 'Schooling']

# Apply Min-Max scaling to the specified columns
scaler = MinMaxScaler()
X[cols_to_scale] = scaler.fit_transform(X[cols_to_scale])

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

import time
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.svm import SVR
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import r2_score
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

algorithms = [
    LinearRegression(),
    DecisionTreeRegressor(),
    RandomForestRegressor(),
    KNeighborsRegressor(),
    XGBRegressor(),
    SVR(),
]

results={
    'Algorithm':[],
    'R2_Score':[],
    'MSE':[],
    'MAE':[],
    'Time':[],
}

for algo in algorithms:
    start_time = time.time()
    algo.fit(X_train, y_train)
    y_pred = algo.predict(X_test)
    end_time = time.time()

    results['Algorithm'].append(algo.__class__.__name__)
    results['R2_Score'].append(r2_score(y_test, y_pred))
    results['MSE'].append(mean_squared_error(y_test, y_pred))
    results['MAE'].append(mean_absolute_error(y_test, y_pred))
    results['Time'].append(end_time - start_time)

df_results = pd.DataFrame(results)
df_results.sort_values(by='R2_Score', ascending=False, inplace=True)
df_results.reset_index(drop=True, inplace=True)
df_results

reg = RandomForestRegressor(n_estimators=100, random_state=42)
reg.fit(X_train, y_train)

importance = reg.feature_importances_
feature_importance_df = pd.DataFrame({'Feature': X_train.columns, 'Importance': importance})
feature_importance_df.sort_values(by='Importance', ascending=False, inplace=True)
feature_importance_df



from sklearn.decomposition import PCA

pca = PCA()
X_train_pca = pca.fit_transform(X_train)

explained_variance_ratio = pca.explained_variance_ratio_

cumulative_variance_ratio = np.cumsum(explained_variance_ratio)

plt.figure(figsize=(10, 6))
plt.plot(range(1, len(cumulative_variance_ratio) + 1), cumulative_variance_ratio, marker='o')
plt.title('Scree Plot')
plt.xlabel('Number of Principal Components')
plt.ylabel('Cumulative Explained Variance Ratio')
plt.grid()
plt.show()

pca = PCA(n_components=17)

X_train_pca = pca.fit_transform(X_train)
X_test_pca = pca.transform(X_test)

import time
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.svm import SVR
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import r2_score
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

algorithms = [
    LinearRegression(),
    DecisionTreeRegressor(),
    RandomForestRegressor(),
    KNeighborsRegressor(),
    XGBRegressor(),
    SVR(),
]

results={
    'Algorithm':[],
    'R2_Score':[],
    'MSE':[],
    'MAE':[],
    'Time':[],
}
print(X_train_pca.shape , y_train.shape)
for algo in algorithms:
    start_time = time.time()
    algo.fit(X_train_pca, y_train)
    y_pred = algo.predict(X_test_pca)
    end_time = time.time()

    results['Algorithm'].append(algo.__class__.__name__)
    results['R2_Score'].append(r2_score(y_test, y_pred))
    results['MSE'].append(mean_squared_error(y_test, y_pred))
    results['MAE'].append(mean_absolute_error(y_test, y_pred))
    results['Time'].append(end_time - start_time)

df_results = pd.DataFrame(results)
df_results.sort_values(by='R2_Score', ascending=False, inplace=True)
df_results.reset_index(drop=True, inplace=True)
df_results

df.head()

"""XGBoost Regressor with all original Features"""

from sklearn.model_selection import GridSearchCV

param_grid = {
    'n_estimators': [50, 100],               # Number of trees
    'learning_rate': [0.01, 0.05],       # Step size shrinkage
    'max_depth': [3, 5, 7],                    # Maximum depth of a tree
    'min_child_weight': [1, 3, 5, 7],                     # L2 regularization term on weights
    'objective': ['reg:squarederror'],             # Default for regression
}

xgb = XGBRegressor()

# grid_search = GridSearchCV(
#     estimator=model,
#     param_grid=param_grid,
#     scoring='r2',
#     cv=5,
# )
grid_search = GridSearchCV(estimator=xgb, param_grid=param_grid,
                           cv=5, scoring='r2',
                           verbose=2, n_jobs=-1)
grid_search.fit(X_train, y_train)

best_xgb = grid_search.best_estimator_

# Make predictions on the test set using the best model
y_test_pred = best_xgb.predict(X_test)

# Calculate recall for the test set
test_r2 = r2_score(y_test, y_test_pred)

print("Best Parameters:", grid_search.best_params_)
print("Test r2 with Best Model:", test_r2)

model = XGBRegressor(learning_rate=0.05, max_depth=7, min_child_weight=5, n_estimators=100, objective='reg:squarederror')

model.fit(X_train, y_train)

# Make predictions on the test set
y_test_pred = model.predict(X_test)

test_r2 = r2_score(y_test, y_test_pred)
print("Test r2:", test_r2)

from sklearn.model_selection import cross_val_score

scores = cross_val_score(xgb, X_train, y_train, cv=5, scoring='r2',n_jobs=-1)

print("Cross-Validation Scores (Accuracy):", scores)
print()
print("R2 Score:", scores.mean())

